use bson;
use byteorder;

use client::coll::options::WriteModel;
use std::{error, fmt, io, result, sync};

/// A type for results generated by MongoDB related functions, where the Err type is mongodb::Error.
pub type Result<T> = result::Result<T, Error>;

/// The error type for MongoDB operations.
#[derive(Debug)]
pub enum Error {
    /// I/O operation errors of `Read`, `Write`, `Seek`, and associated traits.
    IoError(io::Error),
    /// A BSON struct could not be encoded.
    EncoderError(bson::EncoderError),
    /// A BSON struct could not be decoded.
    DecoderError(bson::DecoderError),
    /// A single-write operation failed.
    WriteError(WriteException),
    /// A bulk-write operation failed due to one or more lower-level write-related errors.
    BulkWriteError(BulkWriteException),
    /// An invalid function or operational argument was provided.
    ArgumentError(String),
    /// A database operation failed to send or receive a reply.
    OperationError(String),
    /// A database operation returned an invalid reply.
    ResponseError(String),
    /// A cursor operation failed to return a cursor.
    CursorNotFoundError,
    /// The application failed to secure the client connection socket due to a poisoned lock.
    LockError,
    /// A standard error with a string description;
    /// a more specific error should generally be used.
    DefaultError(String),
}

/// The error type for Write-related MongoDB operations.
#[derive(Debug, Clone)]
pub struct WriteException {
    write_concern_error: Option<WriteConcernError>,
    write_error: Option<WriteError>,
    message: String,
}

/// The error struct for a write-concern related error.
#[derive(Debug, Clone)]
pub struct WriteConcernError {
    code: i32,
    details: bson::Document,
    message: String,
}

/// The error struct for a write-related error.
#[derive(Debug, Clone)]
pub struct WriteError {
    code: i32,
    message: String,
}

/// The error struct for Bulk-Write related MongoDB operations.
#[derive(Debug, Clone)]
pub struct BulkWriteException {
    processed_requests: Vec<WriteModel>,
    unprocessed_requests: Vec<WriteModel>,
    write_errors: Vec<BulkWriteError>,
    write_concern_error: Option<WriteConcernError>,
    message: String,
}

/// The error struct for a single bulk-write step, indicating the request
/// and its index in the original bulk-write request.
#[derive(Debug, Clone)]
pub struct BulkWriteError {
    index: i32,
    request: Option<WriteModel>,
}

impl<'a> From<&'a str> for Error {
    fn from(s: &str) -> Error {
        Error::DefaultError(s.to_owned())
    }
}

impl From<String> for Error {
    fn from(s: String) -> Error {
        Error::DefaultError(s.to_owned())
    }
}

impl From<WriteException> for Error {
    fn from(err: WriteException) -> Error {
        Error::WriteError(err)
    }
}

impl From<BulkWriteException> for Error {
    fn from(err: BulkWriteException) -> Error {
        Error::BulkWriteError(err)
    }
}

impl From<bson::EncoderError> for Error {
    fn from(err: bson::EncoderError) -> Error {
        Error::EncoderError(err)
    }
}

impl From<bson::DecoderError> for Error {
    fn from(err: bson::DecoderError) -> Error {
        Error::DecoderError(err)
    }
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Error {
        Error::IoError(err)
    }
}

impl From<byteorder::Error> for Error {
    fn from(err: byteorder::Error) -> Error {
        Error::IoError(From::from(err))
    }
}

impl<T> From<sync::PoisonError<T>> for Error {
    fn from(_: sync::PoisonError<T>) -> Error {
        Error::LockError
    }
}

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &Error::WriteError(ref inner) => inner.fmt(fmt),
            &Error::BulkWriteError(ref inner) => inner.fmt(fmt),
            &Error::EncoderError(ref inner) => inner.fmt(fmt),
            &Error::DecoderError(ref inner) => inner.fmt(fmt),
            &Error::IoError(ref inner) => inner.fmt(fmt),
            &Error::ArgumentError(ref inner) => inner.fmt(fmt),
            &Error::OperationError(ref inner) => inner.fmt(fmt),
            &Error::ResponseError(ref inner) => inner.fmt(fmt),
            &Error::CursorNotFoundError => write!(fmt, "No cursor found for cursor operation."),
            &Error::LockError => write!(fmt, "Socket lock poisoned while attempting to access."),
            &Error::DefaultError(ref inner) => inner.fmt(fmt),
        }
    }
}

impl error::Error for Error {
    fn description(&self) -> &str {
        match self {
            &Error::WriteError(ref inner) => inner.description(),
            &Error::BulkWriteError(ref inner) => inner.description(),
            &Error::EncoderError(ref inner) => inner.description(),
            &Error::DecoderError(ref inner) => inner.description(),
            &Error::IoError(ref inner) => inner.description(),
            &Error::ArgumentError(ref inner) => &inner,
            &Error::OperationError(ref inner) => &inner,
            &Error::ResponseError(ref inner) => &inner,
            &Error::CursorNotFoundError => "No cursor found for cursor operation.",
            &Error::LockError => "Socket lock poisoned while attempting to access.",
            &Error::DefaultError(ref inner) => &inner,
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match self {
            &Error::WriteError(ref inner) => Some(inner),
            &Error::BulkWriteError(ref inner) => Some(inner),
            &Error::EncoderError(ref inner) => Some(inner),
            &Error::DecoderError(ref inner) => Some(inner),
            &Error::IoError(ref inner) => Some(inner),
            &Error::ArgumentError(_) => None,
            &Error::OperationError(_) => None,
            &Error::ResponseError(_) => None,
            &Error::CursorNotFoundError => None,
            &Error::LockError => None,
            &Error::DefaultError(_) => None,
        }
    }
}

impl error::Error for WriteException {
    fn description(&self) -> &str {
        &self.message
    }

    fn cause(&self) -> Option<&error::Error> {
        None
    }
}

impl error::Error for BulkWriteException {
    fn description(&self) -> &str {
        &self.message
    }

    fn cause(&self) -> Option<&error::Error> {
        None
    }
}

impl fmt::Display for WriteException {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        let ref wc_err = self.write_concern_error;
        let ref w_err = self.write_error;

        try!(write!(fmt, "WriteException:\n"));
        if wc_err.is_some() {
            try!(write!(fmt, "{:?}\n", wc_err));
        }

        if w_err.is_some() {
            try!(write!(fmt, "{:?}\n", w_err));
        }

        Ok(())
    }
}

impl fmt::Display for BulkWriteException {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        try!(write!(fmt, "BulkWriteException:\n"));

        try!(write!(fmt, "Processed Requests:\n"));
        for v in &self.processed_requests {
            try!(write!(fmt, "{:?}\n", v));
        }

        try!(write!(fmt, "Unprocessed Requests:\n"));
        for v in &self.unprocessed_requests {
            try!(write!(fmt, "{:?}\n", v));
        }

        match self.write_concern_error {
            Some(ref error) => try!(write!(fmt, "{:?}\n", error)),
            None => (),
        }

        for v in &self.write_errors {
            try!(write!(fmt, "{:?}\n", v));
        }

        Ok(())
    }
}

impl fmt::Display for BulkWriteError {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        try!(write!(fmt, "BulkWriteError at index {}: ", self.index));
        match self.request {
            Some(ref request) => try!(write!(fmt, "Failed to execute request {:?}\n.", request)),
            None => try!(write!(fmt, "No additional error information was received.\n")),
        }
        Ok(())
    }
}

impl WriteException {
    pub fn new(wc_err: Option<WriteConcernError>, w_err: Option<WriteError>) -> WriteException {
        let s = if wc_err.is_some() && w_err.is_some() {
            format!("{}\n{}",
                    wc_err.as_ref().unwrap().message.to_owned(),
                    w_err.as_ref().unwrap().message.to_owned())
        } else if wc_err.is_some() {
            wc_err.as_ref().unwrap().message.to_owned()
        } else if w_err.is_some() {
            w_err.as_ref().unwrap().message.to_owned()
        } else {
            "No further information provided.".to_owned()
        };

        WriteException {
            write_concern_error: wc_err,
            write_error: w_err,
            message: s,
        }
    }
}

impl WriteConcernError {
    pub fn new<T: ToString>(code: i32, details: bson::Document, message: T) -> WriteConcernError {
        WriteConcernError {
            code: code,
            details: details,
            message: message.to_string(),
        }
    }
}

impl WriteError {
    pub fn new<T: ToString>(code: i32, message: T) -> WriteError {
        WriteError {
            code: code,
            message: message.to_string(),
        }
    }
}

impl BulkWriteException {
    pub fn new<T: ToString>(processed: Vec<WriteModel>, unprocessed: Vec<WriteModel>,
                            write_errors: Vec<BulkWriteError>, write_concern_error: Option<WriteConcernError>)
                            -> BulkWriteException {

        let mut s = match write_concern_error {
            Some(ref error) => format!("WriteConcernError: {:?}\n", error),
            None => "".to_owned(),
        };

        for v in &write_errors {
            s.push_str(&format!("WriteError: {:?}\n", v)[..]);
        }

        BulkWriteException {
            processed_requests: processed,
            unprocessed_requests: unprocessed,
            write_concern_error: write_concern_error,
            write_errors: write_errors,
            message: s.to_owned(),
        }
    }
}
