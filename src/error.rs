use bson::{self, oid};
use byteorder;
use coll::error::{WriteException, BulkWriteException};
use rustc_serialize::hex;
use std::{error, fmt, io, result, sync};

/// A type for results generated by MongoDB related functions, where the Err type is mongodb::Error.
pub type Result<T> = result::Result<T, Error>;

/// The error type for MongoDB operations.
#[derive(Debug)]
pub enum Error {
    /// I/O operation errors of `Read`, `Write`, `Seek`, and associated traits.
    IoError(io::Error),
    /// A BSON struct could not be encoded.
    EncoderError(bson::EncoderError),
    /// A BSON struct could not be decoded.
    DecoderError(bson::DecoderError),
    /// An ObjectId could not be generated.
    OIDError(oid::Error),
    /// A hexadecimal string could not be converted to bytes.
    FromHexError(hex::FromHexError),
    /// A single-write operation failed.
    WriteError(WriteException),
    /// A bulk-write operation failed due to one or more lower-level write-related errors.
    BulkWriteError(BulkWriteException),
    /// An invalid function or operational argument was provided.
    ArgumentError(String),
    /// A database operation failed to send or receive a reply.
    OperationError(String),
    /// A database operation returned an invalid reply.
    ResponseError(String),
    /// A cursor operation failed to return a cursor.
    CursorNotFoundError,
    /// The application failed to secure the client connection socket due to a poisoned lock.
    PoisonLockError,
    /// A standard error with a string description;
    /// a more specific error should generally be used.
    DefaultError(String),
}

impl<'a> From<Error> for io::Error {
    fn from(err: Error) -> io::Error {
        io::Error::new(io::ErrorKind::Other, err)
    }
}

impl<'a> From<&'a str> for Error {
    fn from(s: &str) -> Error {
        Error::DefaultError(s.to_owned())
    }
}

impl From<String> for Error {
    fn from(s: String) -> Error {
        Error::DefaultError(s.to_owned())
    }
}

impl From<WriteException> for Error {
    fn from(err: WriteException) -> Error {
        Error::WriteError(err)
    }
}

impl From<BulkWriteException> for Error {
    fn from(err: BulkWriteException) -> Error {
        Error::BulkWriteError(err)
    }
}

impl From<bson::EncoderError> for Error {
    fn from(err: bson::EncoderError) -> Error {
        Error::EncoderError(err)
    }
}

impl From<bson::DecoderError> for Error {
    fn from(err: bson::DecoderError) -> Error {
        Error::DecoderError(err)
    }
}

impl From<oid::Error> for Error {
    fn from(err: oid::Error) -> Error {
        Error::OIDError(err)
    }
}

impl From<hex::FromHexError> for Error {
    fn from(err: hex::FromHexError) -> Error {
        Error::FromHexError(err)
    }
}

impl From<io::Error> for Error {
    fn from(err: io::Error) -> Error {
        Error::IoError(err)
    }
}

impl From<byteorder::Error> for Error {
    fn from(err: byteorder::Error) -> Error {
        Error::IoError(From::from(err))
    }
}

impl<T> From<sync::PoisonError<T>> for Error {
    fn from(_: sync::PoisonError<T>) -> Error {
        Error::PoisonLockError
    }
}

impl fmt::Display for Error {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        match self {
            &Error::WriteError(ref inner) => inner.fmt(fmt),
            &Error::BulkWriteError(ref inner) => inner.fmt(fmt),
            &Error::EncoderError(ref inner) => inner.fmt(fmt),
            &Error::DecoderError(ref inner) => inner.fmt(fmt),
            &Error::OIDError(ref inner) => inner.fmt(fmt),
            &Error::FromHexError(ref inner) => inner.fmt(fmt),
            &Error::IoError(ref inner) => inner.fmt(fmt),
            &Error::ArgumentError(ref inner) => inner.fmt(fmt),
            &Error::OperationError(ref inner) => inner.fmt(fmt),
            &Error::ResponseError(ref inner) => inner.fmt(fmt),
            &Error::CursorNotFoundError => write!(fmt, "No cursor found for cursor operation."),
            &Error::PoisonLockError => write!(fmt, "Socket lock poisoned while attempting to access."),
            &Error::DefaultError(ref inner) => inner.fmt(fmt),
        }
    }
}

impl error::Error for Error {
    fn description(&self) -> &str {
        match self {
            &Error::WriteError(ref inner) => inner.description(),
            &Error::BulkWriteError(ref inner) => inner.description(),
            &Error::EncoderError(ref inner) => inner.description(),
            &Error::DecoderError(ref inner) => inner.description(),
            &Error::OIDError(ref inner) => inner.description(),
            &Error::FromHexError(ref inner) => inner.description(),
            &Error::IoError(ref inner) => inner.description(),
            &Error::ArgumentError(ref inner) => &inner,
            &Error::OperationError(ref inner) => &inner,
            &Error::ResponseError(ref inner) => &inner,
            &Error::CursorNotFoundError => "No cursor found for cursor operation.",
            &Error::PoisonLockError => "Socket lock poisoned while attempting to access.",
            &Error::DefaultError(ref inner) => &inner,
        }
    }

    fn cause(&self) -> Option<&error::Error> {
        match self {
            &Error::WriteError(ref inner) => Some(inner),
            &Error::BulkWriteError(ref inner) => Some(inner),
            &Error::EncoderError(ref inner) => Some(inner),
            &Error::DecoderError(ref inner) => Some(inner),
            &Error::OIDError(ref inner) => Some(inner),
            &Error::FromHexError(ref inner) => Some(inner),
            &Error::IoError(ref inner) => Some(inner),
            &Error::ArgumentError(_) => None,
            &Error::OperationError(_) => None,
            &Error::ResponseError(_) => None,
            &Error::CursorNotFoundError => None,
            &Error::PoisonLockError => None,
            &Error::DefaultError(_) => None,
        }
    }
}

#[allow(non_camel_case_types)]
#[derive(Debug, PartialEq, Eq)]
pub enum ErrorCode {
    OK = 0,
    InternalError = 1,
    BadValue = 2,
    OBSOLETE_DuplicateKey = 3,
    NoSuchKey = 4,
    GraphContainsCycle = 5,
    HostUnreachable = 6,
    HostNotFound = 7,
    UnknownError = 8,
    FailedToParse = 9,
    CannotMutateObject = 10,
    UserNotFound = 11,
    UnsupportedFormat = 12,
    Unauthorized = 13,
    TypeMismatch = 14,
    Overflow = 15,
    InvalidLength = 16,
    ProtocolError = 17,
    AuthenticationFailed = 18,
    CannotReuseObject = 19,
    IllegalOperation = 20,
    EmptyArrayOperation = 21,
    InvalidBSON = 22,
    AlreadyInitialized = 23,
    LockTimeout = 24,
    RemoteValidationError = 25,
    NamespaceNotFound = 26,
    IndexNotFound = 27,
    PathNotViable = 28,
    NonExistentPath = 29,
    InvalidPath = 30,
    RoleNotFound = 31,
    RolesNotRelated = 32,
    PrivilegeNotFound = 33,
    CannotBackfillArray = 34,
    UserModificationFailed = 35,
    RemoteChangeDetected = 36,
    FileRenameFailed = 37,
    FileNotOpen = 38,
    FileStreamFailed = 39,
    ConflictingUpdateOperators = 40,
    FileAlreadyOpen = 41,
    LogWriteFailed = 42,
    CursorNotFound = 43,
    UserDataInconsistent = 45,
    LockBusy = 46,
    NoMatchingDocument = 47,
    NamespaceExists = 48,
    InvalidRoleModification = 49,
    ExceededTimeLimit = 50,
    ManualInterventionRequired = 51,
    DollarPrefixedFieldName = 52,
    InvalidIdField = 53,
    NotSingleValueField = 54,
    InvalidDBRef = 55,
    EmptyFieldName = 56,
    DottedFieldName = 57,
    RoleModificationFailed = 58,
    CommandNotFound = 59,
    DatabaseNotFound = 60,
    ShardKeyNotFound = 61,
    OplogOperationUnsupported = 62,
    StaleShardVersion = 63,
    WriteConcernFailed = 64,
    MultipleErrorsOccurred = 65,
    ImmutableField = 66,
    CannotCreateIndex = 67,
    IndexAlreadyExists = 68,
    AuthSchemaIncompatible = 69,
    ShardNotFound = 70,
    ReplicaSetNotFound = 71,
    InvalidOptions = 72,
    InvalidNamespace = 73,
    NodeNotFound = 74,
    WriteConcernLegacyOK = 75,
    NoReplicationEnabled = 76,
    OperationIncomplete = 77,
    CommandResultSchemaViolation = 78,
    UnknownReplWriteConcern = 79,
    RoleDataInconsistent = 80,
    NoWhereParseContext = 81,
    NoProgressMade = 82,
    RemoteResultsUnavailable = 83,
    DuplicateKeyValue = 84,
    IndexOptionsConflict = 85,
    IndexKeySpecsConflict = 86,
    CannotSplit = 87,
    SplitFailed = 88,
    NetworkTimeout = 89,
    CallbackCanceled = 90,
    ShutdownInProgress = 91,
    SecondaryAheadOfPrimary = 92,
    InvalidReplicaSetConfig = 93,
    NotYetInitialized = 94,
    NotSecondary = 95,
    OperationFailed = 96,
    NoProjectionFound = 97,
    DBPathInUse = 98,
    WriteConcernNotDefined = 99,
    CannotSatisfyWriteConcern = 100,
    OutdatedClient = 101,
    IncompatibleAuditMetadata = 102,
    NewReplicaSetConfigurationIncompatible = 103,
    NodeNotElectable = 104,
    IncompatibleShardingMetadata = 105,
    DistributedClockSkewed = 106,
    LockFailed = 107,
    InconsistentReplicaSetNames = 108,
    ConfigurationInProgress = 109,
    CannotInitializeNodeWithData = 110,
    NotExactValueField = 111,
    WriteConflict = 112,
    InitialSyncFailure = 113,
    InitialSyncOplogSourceMissing = 114,
    CommandNotSupported = 115,
    DocTooLargeForCapped = 116,
    ConflictingOperationInProgress = 117,
    NamespaceNotSharded = 118,
    InvalidSyncSource = 119,
    OplogStartMissing = 120,
    DocumentValidationFailure = 121,
    OBSOLETE_ReadAfterOptimeTimeout = 122,
    NotAReplicaSet = 123,
    IncompatibleElectionProtocol = 124,
    CommandFailed = 125,
    RPCProtocolNegotiationFailed = 126,
    UnrecoverableRollbackError = 127,
    LockNotFound = 128,
    LockStateChangeFailed = 129,
    SymbolNotFound = 130,
    RLPInitializationFailed = 131,
    ConfigServersInconsistent = 132,
    FailedToSatisfyReadPreference = 133,
    XXX_TEMP_NAME_ReadCommittedCurrentlyUnavailable = 134,
    StaleTerm = 135,
    CappedPositionLost = 136,
    IncompatibleShardingConfigVersion = 137,
    RemoteOplogStale = 138,
    JSInterpreterFailure = 139,
    NotMaster = 10107,
    DuplicateKey = 11000,
    InterruptedAtShutdown = 11600,
    Interrupted = 11601,
    BackgroundOperationInProgressForDatabase = 12586,
    BackgroundOperationInProgressForNamespace = 12587,
    PrepareConfigsFailedCode = 13104,
    DatabaseDifferCase = 13297,
    ShardKeyTooBig = 13334,
    SendStaleConfig = 13388,
    NotMasterNoSlaveOkCode = 13435,
    NotMasterOrSecondaryCode = 13436,
    OutOfDiskSpace = 14031,
    KeyTooLong = 17280,
    MaxError
}

impl ErrorCode {
    pub fn is_network_error(&self) -> bool {
        *self == ErrorCode::HostUnreachable ||
        *self == ErrorCode::HostNotFound ||
        *self == ErrorCode::NetworkTimeout
    }

    pub fn is_interruption(&self) -> bool {
        *self == ErrorCode::Interrupted ||
        *self == ErrorCode::InterruptedAtShutdown ||
        *self == ErrorCode::ExceededTimeLimit
    }

    pub fn is_index_creation_error(&self) -> bool {
        *self == ErrorCode::CannotCreateIndex ||
        *self == ErrorCode::IndexOptionsConflict ||
        *self == ErrorCode::IndexKeySpecsConflict ||
        *self == ErrorCode::IndexAlreadyExists
    }
}
